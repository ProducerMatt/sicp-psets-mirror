<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<!--Converted with LaTeX2HTML 96.1-h (September 30, 1996) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds -->
<HTML>

<!-- Mirrored from groups.csail.mit.edu/mac/classes/6.001/ST98/psets/ps12web/ps12-reg/node2.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 06 Aug 2022 23:01:22 GMT -->
<HEAD>
<TITLE>To do in lab</TITLE>
<META NAME="description" CONTENT="To do in lab">
<META NAME="keywords" CONTENT="ps12-reg">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<LINK REL=STYLESHEET HREF="ps12-reg.css">
</HEAD>
<BODY LANG="EN" >
 <A NAME="tex2html27" HREF="node3.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="http://swissnet.ai.mit.edu/latex2html-lib/icons/next_motif.gif"></A> <A NAME="tex2html25" HREF="ps12-reg.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="http://swissnet.ai.mit.edu/latex2html-lib/icons/up_motif.gif"></A> <A NAME="tex2html19" HREF="node1.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="http://swissnet.ai.mit.edu/latex2html-lib/icons/previous_motif.gif"></A>   <BR>
<B> Next:</B> <A NAME="tex2html28" HREF="node3.html">  About this document </A>
<B>Up:</B> <A NAME="tex2html26" HREF="ps12-reg.html">No Title</A>
<B> Previous:</B> <A NAME="tex2html20" HREF="node1.html">Tutorial Preparation</A>
<BR> <P>
<H1><A NAME="SECTION00020000000000000000">To do in lab</A></H1>
<P>
In lab, you will use the register machine simulator to test the
register machines you designed in the tutorial exercises.  To use the
simulator, load the code for problem set 12 and type in your machine
definitions.  For example you might use something like:
<P>
<TT>
<PRE> (define my-machine
  (make-machine
   '(x l val ...)      ; list the registers you will use here
   standard-primitives ; + - * / inc, etc.
   '((test ...) ; add your machine controller code here
     \vdots
     )))</PRE></TT>
<P>
You will find it convenient to define test procedures that load an
input into a machine, run the machine, print some statistics, and
return the result computed by the machine.  Here is an example that
works for a machine that has an input register <TT>lst</TT> and returns
its result in register <TT>result</TT>.  Depending on how you design your
machine, you may need to make your own version:
<P>
<TT>
<PRE>(define (test-machine machine arg)
  (set-register-contents! machine 'lst arg)
  (newline)
  (display &quot;;Resetting... ignore&quot;)
  (let ((the-stack (machine 'stack)))
    (the-stack 'initialize)
    (newline)
    (display &quot;;Running on arg: &quot;) (display arg)
    (start machine)
    (newline)
    (display &quot;;Run complete:&quot;)
    (the-stack 'print-statistics))
  (get-register-contents machine 'result))</PRE></TT>
<P>
Notice that we use the approximation that the number of operations
performed is proportional to the number of save operations performed.
This is a pretty good approximation for code from our compiler, but it
isn't good for hand written code.
<P>
<H4><A NAME="SECTION00020010000000000000">Computer exercise 1A:</A></H4>
<P>
Debug your machines, run them on some representative inputs, and make
a table that records the number of stack pushes (our approximation for
the number of operations) and maximum stack depth (our approximation
for the amount of space required) as a function of the length of the
list.
<P>
<H4><A NAME="SECTION00020020000000000000">Written exercise 1B:</A></H4>
<P>
Try to derive formulas for the total number of pushes and maximum
stack depth used by your machines, as functions of the length of the
list.  In most cases, the functions will turn out to be polynomials in
the list length, in which case you should be able to exhibit exact
formulas, not just orders of growth.
<P>
Having built hand-crafted register machines for our problem, we now
want to compare their performance with code generated by the compiler
and code generated by the evaluator.
<P>
<table border=3 bordercolor=red>
<tr>
<td align=center><font size=-1><a
href="http://db.photo.net/bboard/cc.tcl?topic=6001ps12&amp;key=computer-ex-01">
Check the 6.001 discussion forum for computer-ex-01</a>
<tr>
<td align=center>
<font size=-1>
Look <a href="http://swissnet.ai.mit.edu/6001/discussion-forum.html">here</a>
for information about the forum.
</table>
<P>
<H3><A NAME="SECTION00020100000000000000">Running the Compiler</A></H3>
<P>
There are two ways to run the compiler.  First, you may simply compile
an expression and obtain the list of machine instructions as a result,
so that you can study it.  For instance,
<P>
<TT>
<PRE>(define test-expression 
   '(define (f x y) (* (+ x y) (- x y))))

(define result (compile test-expression 'val 'return))

(pp result)</PRE></TT>
<P>
The second way to run the compiler is to apply the procedure <TT>
compile-and-go</TT> to the expression.  This compiles the expression and
executes it in the environment of the explicit control evaluator
machine <TT>eceval</TT>.  When evaluation is complete, you are left in
the read-eval-print loop talking to the explicit control evaluator.
Then you can experiment with the compiled expression by evaluating
further expressions.
<P>
<H3><A NAME="SECTION00020200000000000000">Running the Evaluator</A></H3>
<P>
The evaluator for this problem set is the explicit control evaluator
of section 5.4.  <B>Warning:</B> the explict control evaluator and the
compiler do <EM>not</EM> handle the special forms <TT>cond</TT> or <TT>
let</TT>, so be sure any Scheme code you intend to use doesn't use them!
<P>
To evaluate an expression in the <TT>eceval</TT> read-eval-print loop,
type the expression after the prompt, followed by <TT>ctrl-X ctrl-E</TT>.
After each evaluation, the simulator will print the number of stack
and machine operations required to execute the code.<A NAME="tex2html3" HREF="footnode.html#179"><IMG  ALIGN=BOTTOM ALT="gif" SRC="http://swissnet.ai.mit.edu/latex2html-lib/icons/foot_motif.gif"></A>
<P>
Note that you can start up the evaluator by invoking <TT>
(start-eceval)</TT> or you can use <TT>compile-and-go</TT> to enter the
evaluator.  Here is an example:
<P>
<TT>
<PRE>(compile-and-go
 '(define (fact n) (if (= n 0) 1 (* n (fact (- n 1))))))
(total-pushes = 0 maximum-depth = 0)
;;; EC-Eval value:
ok</PRE></TT>
<P>
<TT>
<PRE>;;; EC-Eval input:
(fact 4)          &lt;== you type this, then C-X C-E
(total-pushes = 31 maximum-depth = 14)
;;; EC-Eval value:
24</PRE></TT>
<P>
<TT>
<PRE>;;; EC-Eval input:
(fact (fact 3))   &lt;== you type this
(total-pushes = 68 maximum-depth = 20)
;;; EC-Eval value:
720</PRE></TT>
<P>
<TT>
<PRE>;;; EC-Eval input:
fact
(total-pushes = 0 maximum-depth = 0)
;;; EC-Eval value:
&lt;compiled-procedure&gt;</PRE></TT>
<P>
<TT>
<PRE>;;; EC-Eval input:
(define (fact n) (if (= n 0) 1 (* n (fact (- n 1))))) ;&lt;== fact gets redefined
(total-pushes = 3 maximum-depth = 3)
;;; EC-Eval value:
ok</PRE></TT>
<P>
<TT>
<PRE>;;; EC-Eval input:
fact
(total-pushes = 0 maximum-depth = 0)
;;; EC-Eval value:
(compound-procedure (n) ((if (= n 0) 1 (* n (fact (- n 1))))) &lt;procedure-env&gt;)</PRE></TT>
<P>
<TT>
<PRE>;;; EC-Eval input:
(fact 4)                ;&lt;== redefined fact gets interpreted -- slower!
(total-pushes = 144 maximum-depth = 20)
;;; EC-Eval value:
24</PRE></TT>
<P>
To exit back to regular Scheme type <TT>ctrl-C ctrl-C</TT>.  To re-enter the
evaluator with the previous global environment, you may do another <TT>
compile-and-go</TT>.  To start the evaluator with a reinitialized global
environment, evaluate <TT>(start-eceval)</TT>.  To restart the
read-eval-print loop <EM>without</EM> clearing the global environment, do
<TT>(continue-eceval)</TT>.
<P>
<H4><A NAME="SECTION00020210000000000000">Computer exercise 2A:</A></H4>
<P>
Compile and run the (Scheme) definitions of your two <TT>minabs</TT>
procedures, and make tables to record statistics.
<P>
<H4><A NAME="SECTION00020220000000000000">Computer exercise 2B:</A></H4>
<P>
Now redefine your two <TT>minabs</TT> procedures
within the <TT>eceval</TT> read-eval-print loop and record
corresponding statistics for the interpreted definitions.
<P>
<H4><A NAME="SECTION00020230000000000000">Written exercise 2C:</A></H4>
<P>
Derive formulas for the total number of pushes and maximum stack depth
required, as functions of the length of the list, for the compiled and
interpreted procedures.
<P>
<H4><A NAME="SECTION00020240000000000000">Written exercise 2D:</A></H4>
<P>
We'll consider the time used for a computation to be the total number
of stack pushes, and the space used to be the maximum stack depth.
For each of your procedures, determine the limiting ratio, as the list
length becomes large, of the time and space requirements for your
hand-coded machines, versus the time and space requirements for the
compiled and interpreted code.
<P>
<table border=3 bordercolor=red>
<tr>
<td align=center><font size=-1><a
href="http://db.photo.net/bboard/cc.tcl?topic=6001ps12&amp;key=computer-ex-02">
Check the 6.001 discussion forum for computer-ex-02</a>
<tr>
<td align=center>
<font size=-1>
Look <a href="http://swissnet.ai.mit.edu/6001/discussion-forum.html">here</a>
for information about the forum.
</table>
<P>
<P><P>
<P>
<H4><A NAME="SECTION00020250000000000000">Computer exercise 3A:</A></H4>
<P>
Make listings of the code generated by the compiler for the
definitions of your two procedures.  Annotate these listings to
indicate what various portions of the generated register code
corresponds to, e.g. procedure definition, construction of argument
lists, procedure application, etc.
<P>
<H4><A NAME="SECTION00020260000000000000">Written exercise 3B:</A></H4>
<P>
Compare the listings with your hand-coded versions to see why the
compiler's code is less efficient than yours.  Suggest one improvement
to the compiler that could lead it to do a better job.  Write one or
two clear paragraphs indicating how you might go about implementing
your improvement.  You needn't actually carry out the the
implementation, but your description should be reasonably precise.
For example, you should say what new information the compiler should
keep track of, what new data structures may be required to maintain
this information, and how the information should be used in generating
the new, improved code.
<P>
<table border=3 bordercolor=red>
<tr>
<td align=center><font size=-1><a
href="http://db.photo.net/bboard/cc.tcl?topic=6001ps12&amp;key=computer-ex-03">
Check the 6.001 discussion forum for computer-ex-03</a>
<tr>
<td align=center>
<font size=-1>
Look <a href="http://swissnet.ai.mit.edu/6001/discussion-forum.html">here</a>
for information about the forum.
</table>
<P>
<P><P>
<P>
<H4><A NAME="SECTION00020270000000000000">Computer exercise 4:</A></H4>
<P>
To gain more understanding of the compiler (as described in Chapter 5
of the book), you will next make a small change to the language and
modify the compiler accordingly.  In particular, we wish to change
variable assignment to actually return a useful value, in this case
the new value of the variable.  For example
<P>
<TT>
<PRE>(define x 1)
(set! x 2)
; Value: 2

(* (set! x (+ x 1)) 10)
; Value: 30</PRE></TT>
<P>
To do this problem, you will need to think carefully about how the
compiler generates code and ``preserves'' registers by using the stack.
You should not add any new registers to your machine.  You will also
have to consider (at least when you are testing your code) what order
arguments are evaluated in - we've said ``in any order'' but the
compiler and the interpreter use a particular order (and is it the
same?).
<P>
Turn in listings of your modifications to the compiler, together with
test cases that show both the compiled code generated (using <TT>
compile-and-display</TT>) and the results returned for your test cases
(using <TT>compile-and-go</TT>).  Remember, compiled code for your
<TT>set!</TT> expressions will have this new behavior, but <TT>eceval</TT>
itself will not, so keep this in mind when you are debugging.
<P>
Some test cases you should consider include:
<P>
<TT>
<PRE>(set! x 1)
(set! x (+ 1 2))
(begin (set! x (+ 1 2)) 3)
(+ x (set! x 10))</PRE></TT>
<P>
<table border=3 bordercolor=red>
<tr>
<td align=center><font size=-1><a
href="http://db.photo.net/bboard/cc.tcl?topic=6001ps12&amp;key=computer-ex-04">
Check the 6.001 discussion forum for computer-ex-04</a>
<tr>
<td align=center>
<font size=-1>
Look <a href="http://swissnet.ai.mit.edu/6001/discussion-forum.html">here</a>
for information about the forum.
</table>
<P>
<P><P>
<P>
That's all folks - the last problem set!  We hope you have found them
entertaining, engrossing, and educational.
<P>
<HR><A NAME="tex2html27" HREF="node3.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="http://swissnet.ai.mit.edu/latex2html-lib/icons/next_motif.gif"></A> <A NAME="tex2html25" HREF="ps12-reg.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="http://swissnet.ai.mit.edu/latex2html-lib/icons/up_motif.gif"></A> <A NAME="tex2html19" HREF="node1.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="http://swissnet.ai.mit.edu/latex2html-lib/icons/previous_motif.gif"></A>   <BR>
<B> Next:</B> <A NAME="tex2html28" HREF="node3.html">  About this document </A>
<B>Up:</B> <A NAME="tex2html26" HREF="ps12-reg.html">No Title</A>
<B> Previous:</B> <A NAME="tex2html20" HREF="node1.html">Tutorial Preparation</A>
<P><ADDRESS>
<I>Hal Abelson <BR>
Mon Apr 27 14:24:27 EDT 1998</I>
</ADDRESS>
</BODY>

<!-- Mirrored from groups.csail.mit.edu/mac/classes/6.001/ST98/psets/ps12web/ps12-reg/node2.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 06 Aug 2022 23:01:22 GMT -->
</HTML>
