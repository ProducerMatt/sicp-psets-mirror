<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.2//EN">
<HTML>

<!-- Mirrored from groups.csail.mit.edu/mac/classes/6.001/ST98/psets/ps1web/ps1-ans.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 06 Aug 2022 23:00:13 GMT -->
<HEAD>
<center>
MASSACHVSETTS INSTITVTE OF TECHNOLOGY <BR> 
Department of Electrical Engineering and Computer Science <BR> 
6.001--Structure and Interpretation of Computer Programs <BR> 
Spring Semester, 1998 <BR> 
<P>
</center>
<META NAME="generator" CONTENT="txt2html v1.24">
</HEAD>
<BODY>
<P>

<center>
<B>
Problem Set 1 Solutions
</B>
</center>


<P>
The purpose of these exercises was for you to understand how to create procedures and how you can pass them as arguments to other procedures.


<A NAME="section-1"><H3>Computer Exercise 1:</H3></A>


<P>
<B>
Part A:
</B>


<P> To create a picture that is upside down with respect to the one
generated by the example we need the brightness to increase uniformly
as you move diagonally from black near (0, 127) to white near (127,
0). This implies that diagonal lines with a positive slope should have
a constant brightness value. This is achieved by letting the
brightness at point (x, y) be x - y. The following procedure call
achieves this behavior:

<PRE>
        (picture-display g2 (procedure-&gt;picture 128 128 -))
</PRE>



<P>
<B>
Part B:
</B>


<P> For the brightness to increase horizontally from left to right,
each vertical line should have a constant brightness and the
brightness should increase as we move to the right. By letting the
brightness at point (x, y) be x we get the correct gradient. The
following procedures implement this:

<PRE>
        (define (left-to-right x y) x)

        (picture-display g3 (procedure-&gt;picture 128 128 left-to-right))
</PRE>


<P>
Alternatively, we could use a lambda expression in substitution of the left-to-right procedure:

<PRE>
        (picture-display g3 (procedure-&gt;picture 128 128 (lambda(x y) x)))
</PRE>


<P>
<B>
Part C:
</B>


<P> To obtain a pattern where the brightness increases uniformly as we
move outward from the center of the window, each circle around the
center should have a constant brightness. Thus, we could let the
brightness at point (x, y) be sqrt(x^2 + y^2).

<P> However, we also need to consider that the coordinates of our
windows go from 0 to 128 on each axis, so we need to place the centers
of the circles at the center of the window (i.e. (64, 64) ) by
shifting each circle 64 units in the x-direction and 64 units in the
y-direction. Hence, the brightness at point (x, y) should be sqrt((x -
64)^2 + (y - 64)^2).  The following procedures implement this:

<PRE>
        (define (outwards x y)
          (sqrt (+ (square (- x 64)) (square (- y 64)))))

        (picture-display g1 (procedure-&gt;picture 128 128 outwards))
</PRE>


<P>
Again, we could use a lambda expression in place of the procedure <tt>outwards</tt>:


<PRE>
        (picture-display g1 (procedure-&gt;picture 128 128
                              (lambda (x y)
                                (sqrt (+ (square(- x 64)) (square(- y 64)))))))
</PRE>



<A NAME="section-2"><H3>Computer Exercise 2:</H3></A>


<P> The cosine-y-grate procedure should look something like this. Note
that when given an f, the procedure returns a picture that is ready to
be displayed with the picture-display procedure.

<PRE>
        (define (cosine-y-grate f)
          (procedure-&gt;picture 128 128 (lambda (x y) (cos (* f y)))))
</PRE>


<A NAME="section-3"><H3>Computer Exercise 3:</H3></A>


<P>
The cosine-x-grate procedure should be as follows:

<PRE>
        (define (cosine-x-grate f)
          (procedure-&gt;picture 128 128 (lambda (x y) (cos (* f x)))))
</PRE>



<A NAME="section-4"><H3>Computer Exercise 4:</H3></A>


<P> To make the bands run diagonally, we use the cosine of the sum of
x and y. Just as we saw on the example on exercise 1, this yields
lines that run diagonally with a slope of -1. To obtain a cosine
grating that runs diagonally with a slope of 1 (just as in
part (A) of exercise 1), we should take the cosine of x - y.  Here's
the procedure that yields a diagonal cosine grating with a slope of
-1:

<PRE>
        (define (cosine-x-and-y-grate f)
          (procedure-&gt;picture 128 128 (lambda (x y) (cos (* f (+ x y))))))
</PRE>



<A NAME="section-5"><H3>Computer Exercise 5:</H3></A>


<P>
The purpose of this exercise was to show you how you can use procedural abstractions in order to simplify certain programming tasks. In order to obtain the given cosine grate you were asked to first define a procedure that yields the new multiplied-cosines grating directly from the corresponding value at each point (x, y). Then you were asked to use the picture-map abstractions as well as the abstractions you created in exercises 2 and 3 to yield the same grating.


<P>
<B>
Part A:
</B>

<P>
Cosine-multiplied grating calculated at each point:


<PRE>
        (define (cosine-mul-grate f1 f2)
          (procedure-&gt;picture 128 128 (lambda(x y) (* (cos (* f1 x))
                                                      (cos (* f2 y))))))
</PRE>

<P>
<B>
Part B:
</B>


<P>
Now, we use the picture-map, cosine-x-grate and cosine-y-grate abstractions:


<PRE>
        (define (cosine-mul-map-grate f1 f2)
          (picture-map * (cosine-x-grate f1) (cosine-y-grate f2)))
</PRE>

<P>
Note that both approaches yield the same behavior. In part (A) we explicitly let the value at each point (x, y) be cos f1x cos f2y. In part (B), we first generate two pictures: the first will have a value of cos f1x at each point (x, y) while the second will have a value of cos f2y. We use the procedures we defined in exercises 2 and 3 to obtain these two pictures. Then, we use the picture-map abstraction to multiply the value of the two pictures at each point (x, y) which will yield a third picture with a value of cos f1x cos f2y at each point.


<A NAME="section-6"><H3>Computer Exercise 6:</H3></A>


<P> By careful inspection of the mixed picture we can guess that the
grating used to mix the pictures is diagonal and has a negative
slope. From exercise 4, we know that we can obtain this kind of
grating by taking the cosine of x + y. From exercises 2, 3 and 4 we
also know that we can control the frequency by multiplying the cosine
expression by some factor f. With this in mind we define our function
r(x, y):

<PRE>
        (define (r x y)
          (/ (+ 1 (cos (* f (+ x y)))) 2))
</PRE>

<P> After trying a few values of f, we find that f is 1.5 and we can
obtain a picture with the correct grating by evaluating the following
expressions:

<PRE>
        (define f 1.5)

        (define pic2 (procedure-&gt;picture 128 128 r))
</PRE>


<P> Now, we need to multiply each point the original mixed picture by
the value of the points in pic2. Let's assume that we named the mixed
picture pic1 as follows:

<PRE>
        (define pic1 (pgm-file-&gt;picture "mix-sp98.pgm"))
</PRE>


<P> We obtaign the image of the first personality by multiplying the
values of the two pictures using the picture-map abstraction as
follows:


<PRE>
        (define pic3 (picture-map * pic1 pic2))
</PRE>


<P> Then, we obtain the image of the second personality by subtracting
the value at each point in the picture of the personality from the
value of the points in the original mixed picture. To do this, we use
the picture-map abstraction again:

<PRE>
        (define pic4 (picture-map - pic1 pic3))
</PRE>

<P>
Now we can display the pictures of the two personalities (i.e. pic3 and pic4) and we see that the personalities are:

<P>
Counsellor Diana Troi (Marina Sirtis) from Star Trek (empathic
character) and RoboCop (handles the flack).

 

</BODY>

<!-- Mirrored from groups.csail.mit.edu/mac/classes/6.001/ST98/psets/ps1web/ps1-ans.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 06 Aug 2022 23:00:13 GMT -->
</HTML>

